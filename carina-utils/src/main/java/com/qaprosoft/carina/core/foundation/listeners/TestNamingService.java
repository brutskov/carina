/*******************************************************************************
 * Copyright 2020-2022 Zebrunner Inc (https://www.zebrunner.com).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.qaprosoft.carina.core.foundation.listeners;

import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.ITestContext;
import org.testng.ITestNGMethod;
import org.testng.ITestResult;

import com.qaprosoft.carina.core.foundation.commons.SpecialKeywords;
import com.qaprosoft.carina.core.foundation.utils.Configuration;
import com.zebrunner.agent.testng.listener.RunContextService;

public class TestNamingService {
    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
    
    static final ThreadLocal<String> testName = new ThreadLocal<String>();
    private static final ConcurrentHashMap<String, AtomicInteger> testNameInvCounter = new ConcurrentHashMap<>();

    /**
     * Get full test name based on test class, method and other generic information. It is generated by TestNameListener automatically.
     * 
     * @return String test name
     */
    @Deprecated
    public static String getTestName() {
        // TODO: think about returning very simple valid name if nothing was specified yet! Need ITestResult arg for that!
        if (testName.get() == null) {
            throw new RuntimeException("Unable to detect full test name yet!");
        }
        return testName.get();
    }
    
    /**
     * Get full test name based on test class, method and other generic information. It is generated by TestNameListener automatically.
     * 
     * @param result ITestResult
     * @return String test name
     */    
    public static String getTestName(ITestResult result) {
        // do not return name by thread because it is external Zafira call which should override all values
        setTestName(result);
        return testName.get();
    }
    
    /**
     * Set any custom full test name.
     * 
     * @param name String
     * @return String test name
     */ 
    public static String setTestName(String name) {
        LOGGER.warn("Overridden testName: " + name);
        testName.set(name);
        return testName.get();
    }

    
    /**
     * Set full test name based on test class, method and other generic information. It is generated based by ITestResult object.
     * 
     * @param result ITestResult
     * @return String test name
     */     
    @SuppressWarnings("unlikely-arg-type")
    private static String setTestName(ITestResult result) {
        String name = "";
        if (result.getTestContext() == null) {
            throw new RuntimeException("Unable to set Test name without testContext!");
        }

        ITestNGMethod method = result.getMethod();

        name = Configuration.get(Configuration.Parameter.TEST_NAMING_PATTERN);
        name = name.replace(SpecialKeywords.TEST_NAME_MAP, String.valueOf(getTestNameMapName(result)))
                .replace(SpecialKeywords.TEST_NAME_SUITE, String.valueOf(result.getTestContext().getCurrentXmlTest().getName()))
                .replace(SpecialKeywords.TEST_NAME_TUID, String.valueOf(getMethodUID(result)))
                .replace(SpecialKeywords.METHOD_NAME, String.valueOf(method.getMethodName()))
                .replace(SpecialKeywords.METHOD_PRIORITY, String.valueOf(method.getPriority()))
                .replace(SpecialKeywords.METHOD_THREAD_POOL_SIZE, String.valueOf(method.getThreadPoolSize()))
                .replace(SpecialKeywords.METHOD_GROUP_NAMES, Arrays.toString(method.getGroups()))
                .replace(SpecialKeywords.METHOD_DESCRIPTION, String.valueOf(method.getDescription()))
                .replace(SpecialKeywords.TEST_NAME_QUALIFIED_NAME, String.valueOf(method.getQualifiedName()))
                .replace(SpecialKeywords.TEST_NAME_CLASS, method.getTestClass().getRealClass().getSimpleName())
                .replace(SpecialKeywords.TEST_NAME_HOST, String.valueOf(result.getHost() == null ? "localhost" : result.getHost()))
                .replace(SpecialKeywords.TEST_NAME_INSTANCE, String.valueOf(result.getInstanceName()))
                .replace(SpecialKeywords.TEST_NAME_DATA_PROVIDER_LINE, String.valueOf(getDataProviderLine(result)))
                // introduce invocation count calculation here as in multi threading mode TestNG doesn't provide valid
                // getInvocationCount() value
                .replace(SpecialKeywords.TEST_NAME_INVOCATION_COUNT, String.valueOf(appendInvocationCount(result, name)))
                .trim()
                .replaceAll("\\s+", " ");
        LOGGER.debug("testName: {}", name);

        testName.set(name);
        return testName.get();
    }

    // todo add description
    private static String getTestNameMapName(ITestResult result) {
        String testNameMapName = "";
        // todo add description
        @SuppressWarnings("unchecked")
        Map<Object[], String> testNameMap = (Map<Object[], String>) result.getTestContext().getAttribute(SpecialKeywords.TEST_NAME_ARGS_MAP);

        if (testNameMap != null) {
            String testHash = String.valueOf(Arrays.hashCode(result.getParameters()));
            if (testNameMap.containsKey(testHash)) {
                testNameMapName = testNameMap.get(testHash);
            }
        }
        return testNameMapName;
    }

    private static String getMethodUID(ITestResult result) {
        String methodUID = "";
        // TODO: find the bext way to calculate TUID/hash
        if (result.getTestContext().getCurrentXmlTest().getAllParameters().containsKey(SpecialKeywords.EXCEL_DS_CUSTOM_PROVIDER) ||
                result.getTestContext().getCurrentXmlTest().getAllParameters().containsKey(SpecialKeywords.DS_CUSTOM_PROVIDER)) {
            // AUTO-274 "Pass"ing status set on emailable report when a test step fails
            for (int i = 0; i < result.getParameters().length; i++) {
                if (result.getParameters()[i] != null) {
                    if (result.getParameters()[i].toString().contains(SpecialKeywords.TUID + ":")) {
                        methodUID = result.getParameters()[i].toString().replace(SpecialKeywords.TUID + ":", "");
                        break; // first TUID: parameter is used
                    }
                }
            }
        }
        return methodUID;
    }
    
    /**
     * get Test Method name
     *
     * @deprecated
     * @param result ITestResult
     * @return String method name
     */
    @Deprecated(since = "7.4.22", forRemoval = true)
    public static String getMethodName(ITestResult result) {
        // adjust testName using pattern
        ITestNGMethod m = result.getMethod();
        String name = Configuration.get(Configuration.Parameter.TEST_NAMING_PATTERN);
        LOGGER.debug("TestNamingPattern: " + name);
        name = name.replace(SpecialKeywords.METHOD_NAME, m.getMethodName());
        name = name.replace(SpecialKeywords.METHOD_PRIORITY, String.valueOf(m.getPriority()));
        name = name.replace(SpecialKeywords.METHOD_THREAD_POOL_SIZE, String.valueOf(m.getThreadPoolSize()));
        name = name.replace(SpecialKeywords.METHOD_GROUP_NAMES, Arrays.toString(m.getGroups()));

        if (m.getDescription() != null) {
            LOGGER.debug("Test method description: " + m.getDescription());
            name = name.replace(SpecialKeywords.METHOD_DESCRIPTION, m.getDescription());
        } else {
            name = name.replace(SpecialKeywords.METHOD_DESCRIPTION, "");
        }
        
        return name;
    }
    
    /**
     * get Test Package name
     * 
     * @param result ITestResult
     * @return String package name
     */
    public static String getPackageName(ITestResult result) {
        return result.getMethod().getRealClass().getPackage().getName();
    }
    
    /**
     * calculate InvocationCount number based on test name
     * 
     * @param testResult ITestResult
     * @return int invCount
     */
    private static String appendInvocationCount(ITestResult testResult, String testName) {
        String invocationCount = "";
        int expectedInvocationCount = getInvocationCount(testResult);
        if (expectedInvocationCount > 1) {
            // adding extra zero at the beginning of the invocation count
            int indexMaxLength = Integer.toString(expectedInvocationCount).length() + 1;
            String lineFormat = " [InvCount=%0" + indexMaxLength + "d]";
            int currentInvocationCount = testNameInvCounter.computeIfAbsent(testName, $ -> new AtomicInteger(0))
                                                             .incrementAndGet();
            invocationCount = String.format(lineFormat, currentInvocationCount);
        }
        return invocationCount;
    }
    private static int getInvocationCount(ITestResult testResult) {
        ITestNGMethod[] methods = testResult.getTestContext().getAllTestMethods();
        return Arrays.stream(methods)
                     .filter(method -> method.equals(testResult.getMethod()))
                     .findFirst()
                     .map(ITestNGMethod::getInvocationCount)
                     .orElse(0);
    }
    
    private static String getDataProviderLine(ITestResult testResult) {
        String dataProviderLine = "";
        ITestNGMethod testMethod = testResult.getMethod();
        ITestContext testContext = testResult.getTestContext();
        Object[] parameters = testResult.getParameters();

        int dataProviderSize = RunContextService.getDataProviderSize(testMethod, testContext);
        if (dataProviderSize > 0) {
            // adding extra zero at the beginning of the data provider line number
            int indexMaxLength = Integer.toString(dataProviderSize).length() + 1;
            String lineFormat = " [L%0" + indexMaxLength + "d]";
            int index = RunContextService.getCurrentDataProviderIndex(testMethod, testContext, parameters) + 1;
            dataProviderLine = String.format(lineFormat, index);
        }
        return dataProviderLine;
    }
    
}
